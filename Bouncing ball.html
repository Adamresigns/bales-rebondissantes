<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bouncing Ball in a Circle</title>
  <style>
    canvas { background: #eee; display: block; margin: 0 auto; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div style="text-align:center;">
  <label for="speed">Speed:</label>
  <input type="number" id="speed" value="7" step="0.1" onchange="updateSpeed(this.value);" disabled>
  <br>
  <input type="checkbox" id="gravityToggle" onchange="toggleGravity(this.checked);">
  <label for="gravityToggle">Gravity</label>
  <br>
  <input type="checkbox" id="elasticityToggle" onchange="toggleElasticity(this.checked);">
  <label for="elasticityToggle">Elasticity</label>
  <br>
  <div id="scoreDisplay" style="font-size:1.5em; margin-top:10px;">Score: 0</div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const speedInput = document.getElementById('speed');
const scoreDisplay = document.getElementById('scoreDisplay');

const audioContext = new (window.AudioContext || window.webkitAudioContext)();

let score = 0;

let circle = {
  x: 0,
  y: 0,
  radius: 200,
  angle: 0,
  speed: 0.01,
  visible: true
};

let extraCircles = [
  {radius: 250, color: "#bbb", angle: 0, speed: 0.008, visible: true},
  {radius: 300, color: "#aaa", angle: 0, speed: 0.006, visible: true},
  {radius: 350, color: "#888", angle: 0, speed: 0.004, visible: true}
];

let ball = {
  x: 0,
  y: 0,
  radius: 20,
  dx: parseFloat(speedInput.value),
  dy: parseFloat(speedInput.value),
  gravity: 0.1,
  elasticity: 0.8,
  useGravity: false,
  useElasticity: false
};

function playSound(frequency = 440) {
  let oscillator = audioContext.createOscillator();
  oscillator.type = 'sine';
  oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
  oscillator.connect(audioContext.destination);
  oscillator.start();
  oscillator.stop(audioContext.currentTime + 0.1);
}

function updateScore() {
  scoreDisplay.textContent = "Score: " + score;
}

function isOnRedArc(ballX, ballY, circleObj, arcLength) {
  let dist = Math.sqrt(ballX * ballX + ballY * ballY);
  if (Math.abs(dist - circleObj.radius) > ball.radius + 2) return false;
  let angle = Math.atan2(ballY, ballX);
  if (angle < 0) angle += Math.PI * 2;
  let arcAngle = arcLength / circleObj.radius;
  let startAngle = circleObj.angle % (Math.PI * 2);
  let endAngle = (startAngle + arcAngle) % (Math.PI * 2);
  if (startAngle < endAngle) {
    return angle >= startAngle && angle <= endAngle;
  } else {
    return angle >= startAngle || angle <= endAngle;
  }
}

function drawCircle() {
  const arcLength = 100;
  for (let c of extraCircles) {
    if (!c.visible) continue;
    let angle = arcLength / c.radius;
    let startAngle = c.angle;
    let endAngle = startAngle + angle;
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, c.radius, startAngle, endAngle, false);
    ctx.strokeStyle = "red";
    ctx.lineWidth = 6;
    ctx.stroke();
    ctx.closePath();
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, c.radius, 0, Math.PI * 2);
    ctx.strokeStyle = c.color;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.closePath();
  }
  if (circle.visible) {
    let angle = arcLength / circle.radius;
    let startAngle = circle.angle;
    let endAngle = startAngle + angle;
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, circle.radius, startAngle, endAngle, false);
    ctx.strokeStyle = "red";
    ctx.lineWidth = 6;
    ctx.stroke();
    ctx.closePath();
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 4;
    ctx.stroke();
    ctx.closePath();
  }
}

function drawBall() {
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fillStyle = '#0095DD';
  ctx.fill();
  ctx.closePath();
}

function updateBall() {
  const arcLength = 100;
  if (ball.useGravity) {
    ball.dy += ball.gravity;
  }
  ball.x += ball.dx;
  ball.y += ball.dy;

  for (let i = extraCircles.length - 1; i >= 0; i--) {
    let c = extraCircles[i];
    if (!c.visible) continue;
    let dist = Math.sqrt(ball.x * ball.x + ball.y * ball.y);
    if (isOnRedArc(ball.x, ball.y, c, arcLength)) {
      c.visible = false;
      playSound(700);
      score++;
      updateScore();
      continue;
    }
    if (Math.abs(dist - c.radius) < ball.radius + 2) {
      let nx = ball.x / dist;
      let ny = ball.y / dist;
      let dot = ball.dx * nx + ball.dy * ny;
      ball.dx -= 2 * dot * nx * (ball.useElasticity ? ball.elasticity : 1);
      ball.dy -= 2 * dot * ny * (ball.useElasticity ? ball.elasticity : 1);
      ball.x = nx * (c.radius - ball.radius - 0.1);
      ball.y = ny * (c.radius - ball.radius - 0.1);
      playSound(400 + Math.random() * 200);
      return;
    }
  }

  if (circle.visible) {
    let dist = Math.sqrt(ball.x * ball.x + ball.y * ball.y);
    if (isOnRedArc(ball.x, ball.y, circle, arcLength)) {
      circle.visible = false;
      playSound(900);
      score++;
      updateScore();
      return;
    }
    if (dist + ball.radius > circle.radius) {
      let nx = ball.x / dist;
      let ny = ball.y / dist;
      let dot = ball.dx * nx + ball.dy * ny;
      ball.dx -= 2 * dot * nx * (ball.useElasticity ? ball.elasticity : 1);
      ball.dy -= 2 * dot * ny * (ball.useElasticity ? ball.elasticity : 1);
      ball.x = nx * (circle.radius - ball.radius - 0.1);
      ball.y = ny * (circle.radius - ball.radius - 0.1);
      playSound(400 + Math.random() * 200);
      return;
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);
  drawCircle();
  drawBall();
  updateBall();
  ctx.restore();

  circle.angle += circle.speed;
  for (let c of extraCircles) {
    c.angle += c.speed;
  }

  requestAnimationFrame(draw);
}

function toggleGravity(checked) {
  ball.useGravity = checked;
  checkDisabled();
}

function toggleElasticity(checked) {
  ball.useElasticity = checked;
  checkDisabled();
}

function checkDisabled() {
  if (!ball.useGravity && !ball.useElasticity) {
    speedInput.disabled = false;
  } else {
    speedInput.disabled = true;
    speedInput.value = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy).toFixed(1);
  }
}

function updateSpeed(value) {
  ball.dx = parseFloat(value);
  ball.dy = parseFloat(value);
}

function resizeCanvas() {
  const minSize = 800;
  canvas.width = Math.max(window.innerWidth * 0.9, minSize);
  canvas.height = Math.max(window.innerHeight * 0.9, minSize);
  circle.x = 0;
  circle.y = 0;
  if (Math.sqrt(ball.x * ball.x + ball.y * ball.y) + ball.radius > circle.radius) {
    let angle = Math.atan2(ball.y, ball.x);
    ball.x = Math.cos(angle) * (circle.radius - ball.radius - 1);
    ball.y = Math.sin(angle) * (circle.radius - ball.radius - 1);
  }
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);

ball.x = 0;
ball.y = 0;

updateScore();

draw();
</script>
</body>
</html>
