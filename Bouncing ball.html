<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bouncing Ball in a Circle</title>
  <style>
    canvas { background: #eee; display: block; margin: 0 auto; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div style="text-align:center;">
  <label for="speed">Speed:</label>
  <input type="number" id="speed" value="7" step="0.1" onchange="updateSpeed(this.value);" disabled>
  <br>
  <input type="checkbox" id="gravityToggle" onchange="toggleGravity(this.checked);">
  <label for="gravityToggle">Gravity</label>
  <br>
  <input type="checkbox" id="elasticityToggle" onchange="toggleElasticity(this.checked);">
  <label for="elasticityToggle">Elasticity</label>
  <br>
  <div id="scoreDisplay" style="font-size:1.5em; margin-top:10px;">Score Ball 1: <span id="score1">0</span> | Score Ball 2: <span id="score2">0</span></div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const speedInput = document.getElementById('speed');
const score1Display = document.getElementById('score1');
const score2Display = document.getElementById('score2');

const audioContext = new (window.AudioContext || window.webkitAudioContext)();

let score1 = 0;
let score2 = 0;

let circle = {
  x: 0,
  y: 0,
  radius: 200,
  angle: 0,
  speed: 0.01,
  visible: true
};

let extraCircles = [
  {radius: 250, color: "#bbb", angle: 0, speed: 0.008, visible: true},
  {radius: 300, color: "#aaa", angle: 0, speed: 0.006, visible: true},
  {radius: 350, color: "#888", angle: 0, speed: 0.004, visible: true}
];

let ball1 = {
  x: -40,
  y: 0,
  radius: 20,
  dx: parseFloat(speedInput.value),
  dy: parseFloat(speedInput.value),
  gravity: 0.1,
  elasticity: 0.8,
  useGravity: false,
  useElasticity: false
};

let ball2 = {
  x: 40,
  y: 0,
  radius: 20,
  dx: -parseFloat(speedInput.value),
  dy: -parseFloat(speedInput.value),
  gravity: 0.1,
  elasticity: 0.8,
  useGravity: false,
  useElasticity: false
};

function playSound(frequency = 440) {
  let oscillator = audioContext.createOscillator();
  oscillator.type = 'sine';
  oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
  oscillator.connect(audioContext.destination);
  oscillator.start();
  oscillator.stop(audioContext.currentTime + 0.1);
}

function updateScore() {
  score1Display.textContent = score1;
  score2Display.textContent = score2;
}

function isOnRedArc(ballX, ballY, circleObj, arcLength) {
  let dist = Math.sqrt(ballX * ballX + ballY * ballY);
  if (Math.abs(dist - circleObj.radius) > 22) return false;
  let angle = Math.atan2(ballY, ballX);
  if (angle < 0) angle += Math.PI * 2;
  let arcAngle = arcLength / circleObj.radius;
  let startAngle = circleObj.angle % (Math.PI * 2);
  let endAngle = (startAngle + arcAngle) % (Math.PI * 2);
  if (startAngle < endAngle) {
    return angle >= startAngle && angle <= endAngle;
  } else {
    return angle >= startAngle || angle <= endAngle;
  }
}

function drawCircle() {
  const arcLength = 100;
  for (let c of extraCircles) {
    if (!c.visible) continue;
    let angle = arcLength / c.radius;
    let startAngle = c.angle;
    let endAngle = startAngle + angle;
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, c.radius, startAngle, endAngle, false);
    ctx.strokeStyle = "red";
    ctx.lineWidth = 6;
    ctx.stroke();
    ctx.closePath();
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, c.radius, 0, Math.PI * 2);
    ctx.strokeStyle = c.color;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.closePath();
  }
  if (circle.visible) {
    let angle = arcLength / circle.radius;
    let startAngle = circle.angle;
    let endAngle = startAngle + angle;
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, circle.radius, startAngle, endAngle, false);
    ctx.strokeStyle = "red";
    ctx.lineWidth = 6;
    ctx.stroke();
    ctx.closePath();
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 4;
    ctx.stroke();
    ctx.closePath();
  }
}

function drawBall(ball, color) {
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.closePath();
}

function updateBall(ball, extraCircles, circle, scoreRef, soundBase) {
  const arcLength = 100;
  if (ball.useGravity) {
    ball.dy += ball.gravity;
  }
  ball.x += ball.dx;
  ball.y += ball.dy;

  for (let i = extraCircles.length - 1; i >= 0; i--) {
    let c = extraCircles[i];
    if (!c.visible) continue;
    let dist = Math.sqrt(ball.x * ball.x + ball.y * ball.y);
    if (isOnRedArc(ball.x, ball.y, c, arcLength)) {
      c.visible = false;
      playSound(soundBase + 300);
      scoreRef.value++;
      updateScore();
      continue;
    }
    if (Math.abs(dist - c.radius) < ball.radius + 2) {
      let nx = ball.x / dist;
      let ny = ball.y / dist;
      let dot = ball.dx * nx + ball.dy * ny;
      ball.dx -= 2 * dot * nx * (ball.useElasticity ? ball.elasticity : 1);
      ball.dy -= 2 * dot * ny * (ball.useElasticity ? ball.elasticity : 1);
      ball.x = nx * (c.radius - ball.radius - 0.1);
      ball.y = ny * (c.radius - ball.radius - 0.1);
      playSound(soundBase + Math.random() * 200);
      return;
    }
  }

  if (circle.visible) {
    let dist = Math.sqrt(ball.x * ball.x + ball.y * ball.y);
    if (isOnRedArc(ball.x, ball.y, circle, arcLength)) {
      circle.visible = false;
      playSound(soundBase + 500);
      scoreRef.value++;
      updateScore();
      return;
    }
    if (dist + ball.radius > circle.radius) {
      let nx = ball.x / dist;
      let ny = ball.y / dist;
      let dot = ball.dx * nx + ball.dy * ny;
      ball.dx -= 2 * dot * nx * (ball.useElasticity ? ball.elasticity : 1);
      ball.dy -= 2 * dot * ny * (ball.useElasticity ? ball.elasticity : 1);
      ball.x = nx * (circle.radius - ball.radius - 0.1);
      ball.y = ny * (circle.radius - ball.radius - 0.1);
      playSound(soundBase + Math.random() * 200);
      return;
    }
  }
}

// Repulsion between balls
function repelBalls(b1, b2) {
  let dx = b2.x - b1.x;
  let dy = b2.y - b1.y;
  let dist = Math.sqrt(dx * dx + dy * dy);
  let minDist = b1.radius + b2.radius;
  if (dist < minDist && dist > 0) {
    let overlap = minDist - dist + 0.1;
    let nx = dx / dist;
    let ny = dy / dist;
    // Move balls apart
    b1.x -= nx * overlap / 2;
    b1.y -= ny * overlap / 2;
    b2.x += nx * overlap / 2;
    b2.y += ny * overlap / 2;
    // Exchange velocities (elastic collision)
    let dvx = b2.dx - b1.dx;
    let dvy = b2.dy - b1.dy;
    let impact = dvx * nx + dvy * ny;
    if (impact < 0) {
      let impulse = 2 * impact / 2;
      b1.dx += impulse * nx;
      b1.dy += impulse * ny;
      b2.dx -= impulse * nx;
      b2.dy -= impulse * ny;
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);
  drawCircle();
  drawBall(ball1, "#0095DD");
  drawBall(ball2, "#DD9500");
  updateBall(ball1, extraCircles, circle, {get value(){return score1}, set value(v){score1=v}}, 400);
  updateBall(ball2, extraCircles, circle, {get value(){return score2}, set value(v){score2=v}}, 600);
  repelBalls(ball1, ball2);
  ctx.restore();

  circle.angle += circle.speed;
  for (let c of extraCircles) {
    c.angle += c.speed;
  }

  requestAnimationFrame(draw);
}

function toggleGravity(checked) {
  ball1.useGravity = checked;
  ball2.useGravity = checked;
  checkDisabled();
}

function toggleElasticity(checked) {
  ball1.useElasticity = checked;
  ball2.useElasticity = checked;
  checkDisabled();
}

function checkDisabled() {
  if (!ball1.useGravity && !ball1.useElasticity) {
    speedInput.disabled = false;
  } else {
    speedInput.disabled = true;
    speedInput.value = Math.sqrt(ball1.dx * ball1.dx + ball1.dy * ball1.dy).toFixed(1);
  }
}

function updateSpeed(value) {
  ball1.dx = parseFloat(value);
  ball1.dy = parseFloat(value);
  ball2.dx = -parseFloat(value);
  ball2.dy = -parseFloat(value);
}

function resizeCanvas() {
  const minSize = 800;
  canvas.width = Math.max(window.innerWidth * 0.9, minSize);
  canvas.height = Math.max(window.innerHeight * 0.9, minSize);
  circle.x = 0;
  circle.y = 0;
  // Keep balls inside
  for (let ball of [ball1, ball2]) {
    if (Math.sqrt(ball.x * ball.x + ball.y * ball.y) + ball.radius > circle.radius) {
      let angle = Math.atan2(ball.y, ball.x);
      ball.x = Math.cos(angle) * (circle.radius - ball.radius - 1);
      ball.y = Math.sin(angle) * (circle.radius - ball.radius - 1);
    }
  }
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);

ball1.x = -40;
ball1.y = 0;
ball2.x = 40;
ball2.y = 0;

updateScore();

draw();
</script>
</body>
</html>
