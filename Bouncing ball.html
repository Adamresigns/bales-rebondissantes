<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bouncing Ball in a Circle</title>
  <style>
    body {
      background: #070a13;
    }
    canvas {
      background: linear-gradient(135deg, #0ff 0%, #111 100%);
      display: block;
      margin: 0 auto;
      box-shadow: 0 0 60px #0ff, 0 0 120px #00f;
      border-radius: 20px;
    }
    #scoreDisplay, label, input {
      color: #fff;
      text-shadow: 0 0 8px #0ff, 0 0 4px #fff;
      font-weight: bold;
    }
    #scoreDisplay {
      font-size: 1.7em;
      margin-top: 10px;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.4);
      border-radius: 10px;
      padding: 6px 18px;
      display: inline-block;
      box-shadow: 0 0 10px #0ff;
    }
    input[type="number"] {
      background: #222;
      color: #0ff;
      border: 1px solid #0ff;
      border-radius: 5px;
      padding: 2px 6px;
      font-size: 1em;
      box-shadow: 0 0 6px #0ff inset;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div style="text-align:center;">
  <label for="speed">Speed:</label>
  <input type="number" id="speed" value="7" step="0.1" onchange="updateSpeed(this.value);" disabled>
  <br>
  <input type="checkbox" id="gravityToggle" onchange="toggleGravity(this.checked);">
  <label for="gravityToggle">Gravity</label>
  <br>
  <input type="checkbox" id="elasticityToggle" onchange="toggleElasticity(this.checked);">
  <label for="elasticityToggle">Elasticity</label>
  <br>
  <div id="scoreDisplay">Score Ball 1: <span id="score1">0</span> | Score Ball 2: <span id="score2">0</span></div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const speedInput = document.getElementById('speed');
const score1Display = document.getElementById('score1');
const score2Display = document.getElementById('score2');

const audioContext = new (window.AudioContext || window.webkitAudioContext)();

let score1 = 0;
let score2 = 0;

let circle = {
  x: 0,
  y: 0,
  radius: 200,
  angle: 0,
  speed: 0.01,
  visible: true
};

// 6 neon circles with different neon colors
let extraCircles = [
  {radius: 230, color: "#0ff", glow: "#0ff", angle: 0, speed: 0.008, visible: true},
  {radius: 260, color: "#f0f", glow: "#f0f", angle: 0, speed: 0.007, visible: true},
  {radius: 290, color: "#ff0", glow: "#ff0", angle: 0, speed: 0.006, visible: true},
  {radius: 320, color: "#0f0", glow: "#0f0", angle: 0, speed: 0.005, visible: true},
  {radius: 350, color: "#0ff", glow: "#0ff", angle: 0, speed: 0.004, visible: true},
  {radius: 380, color: "#f0f", glow: "#f0f", angle: 0, speed: 0.003, visible: true}
];

function randomBallPosition(radius, ballRadius) {
  // Place randomly inside the main circle, not too close to the edge
  let r = Math.random() * (radius - ballRadius - 10);
  let theta = Math.random() * Math.PI * 2;
  return {
    x: Math.cos(theta) * r,
    y: Math.sin(theta) * r
  };
}

let ball1 = {
  ...randomBallPosition(circle.radius, 20),
  radius: 20,
  dx: parseFloat(speedInput.value),
  dy: parseFloat(speedInput.value),
  gravity: 0.1,
  elasticity: 0.8,
  useGravity: false,
  useElasticity: false
};

let ball2;
do {
  ball2 = {
    ...randomBallPosition(circle.radius, 20),
    radius: 20,
    dx: -parseFloat(speedInput.value),
    dy: -parseFloat(speedInput.value),
    gravity: 0.1,
    elasticity: 0.8,
    useGravity: false,
    useElasticity: false
  };
  // Make sure balls don't overlap at start
} while (Math.hypot(ball1.x - ball2.x, ball1.y - ball2.y) < 40);

function playSound(frequency = 440) {
  let oscillator = audioContext.createOscillator();
  oscillator.type = 'sine';
  oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
  oscillator.connect(audioContext.destination);
  oscillator.start();
  oscillator.stop(audioContext.currentTime + 0.1);
}

function updateScore() {
  score1Display.textContent = score1;
  score2Display.textContent = score2;
}

function isOnRedArc(ballX, ballY, circleObj, arcLength) {
  let dist = Math.sqrt(ballX * ballX + ballY * ballY);
  if (Math.abs(dist - circleObj.radius) > 22) return false;
  let angle = Math.atan2(ballY, ballX);
  if (angle < 0) angle += Math.PI * 2;
  let arcAngle = arcLength / circleObj.radius;
  let startAngle = circleObj.angle % (Math.PI * 2);
  let endAngle = (startAngle + arcAngle) % (Math.PI * 2);
  if (startAngle < endAngle) {
    return angle >= startAngle && angle <= endAngle;
  } else {
    return angle >= startAngle || angle <= endAngle;
  }
}

// Draw circles with the "red" (now invisible) arc missing, with neon glow
function drawCircle() {
  const arcLength = 100;
  for (let c of extraCircles) {
    if (!c.visible) continue;
    let angle = arcLength / c.radius;
    let startAngle = c.angle;
    let endAngle = startAngle + angle;
    // Neon glow for circles
    ctx.save();
    ctx.shadowColor = c.glow;
    ctx.shadowBlur = 30;
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, c.radius, endAngle, startAngle + 2 * Math.PI, false);
    ctx.strokeStyle = c.color;
    ctx.lineWidth = 4;
    ctx.stroke();
    ctx.closePath();
    ctx.restore();
  }
  if (circle.visible) {
    let angle = arcLength / circle.radius;
    let startAngle = circle.angle;
    let endAngle = startAngle + angle;
    ctx.save();
    ctx.shadowColor = "#0ff";
    ctx.shadowBlur = 40;
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, circle.radius, endAngle, startAngle + 2 * Math.PI, false);
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 6;
    ctx.stroke();
    ctx.closePath();
    ctx.restore();
  }
}

function drawBall(ball, color, glow) {
  ctx.save();
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.shadowColor = glow;
  ctx.shadowBlur = 40;
  ctx.fillStyle = color;
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.closePath();
  ctx.restore();
}

function updateBall(ball, extraCircles, circle, scoreRef, soundBase) {
  const arcLength = 100;
  if (ball.useGravity) {
    ball.dy += ball.gravity;
  }
  ball.x += ball.dx;
  ball.y += ball.dy;

  for (let i = extraCircles.length - 1; i >= 0; i--) {
    let c = extraCircles[i];
    if (!c.visible) continue;
    let dist = Math.sqrt(ball.x * ball.x + ball.y * ball.y);
    if (isOnRedArc(ball.x, ball.y, c, arcLength)) {
      c.visible = false;
      playSound(soundBase + 300);
      scoreRef.value++;
      updateScore();
      continue;
    }
    if (Math.abs(dist - c.radius) < ball.radius + 2) {
      let nx = ball.x / dist;
      let ny = ball.y / dist;
      let dot = ball.dx * nx + ball.dy * ny;
      ball.dx -= 2 * dot * nx * (ball.useElasticity ? ball.elasticity : 1);
      ball.dy -= 2 * dot * ny * (ball.useElasticity ? ball.elasticity : 1);
      ball.x = nx * (c.radius - ball.radius - 0.1);
      ball.y = ny * (c.radius - ball.radius - 0.1);
      playSound(soundBase + Math.random() * 200);
      return;
    }
  }

  if (circle.visible) {
    let dist = Math.sqrt(ball.x * ball.x + ball.y * ball.y);
    if (isOnRedArc(ball.x, ball.y, circle, arcLength)) {
      circle.visible = false;
      playSound(soundBase + 500);
      scoreRef.value++;
      updateScore();
      return;
    }
    if (dist + ball.radius > circle.radius) {
      let nx = ball.x / dist;
      let ny = ball.y / dist;
      let dot = ball.dx * nx + ball.dy * ny;
      ball.dx -= 2 * dot * nx * (ball.useElasticity ? ball.elasticity : 1);
      ball.dy -= 2 * dot * ny * (ball.useElasticity ? ball.elasticity : 1);
      ball.x = nx * (circle.radius - ball.radius - 0.1);
      ball.y = ny * (circle.radius - ball.radius - 0.1);
      playSound(soundBase + Math.random() * 200);
      return;
    }
  }
}

function repelBalls(b1, b2) {
  let dx = b2.x - b1.x;
  let dy = b2.y - b1.y;
  let dist = Math.sqrt(dx * dx + dy * dy);
  let minDist = b1.radius + b2.radius;
  if (dist < minDist && dist > 0) {
    let overlap = minDist - dist + 0.1;
    let nx = dx / dist;
    let ny = dy / dist;
    b1.x -= nx * overlap / 2;
    b1.y -= ny * overlap / 2;
    b2.x += nx * overlap / 2;
    b2.y += ny * overlap / 2;
    let dvx = b2.dx - b1.dx;
    let dvy = b2.dy - b1.dy;
    let impact = dvx * nx + dvy * ny;
    if (impact < 0) {
      let impulse = 2 * impact / 2;
      b1.dx += impulse * nx;
      b1.dy += impulse * ny;
      b2.dx -= impulse * nx;
      b2.dy -= impulse * ny;
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);
  drawCircle();
  drawBall(ball1, "#00f6ff", "#00f6ff"); // Neon blue
  drawBall(ball2, "#ff0066", "#ff0066"); // Neon red
  updateBall(ball1, extraCircles, circle, {get value(){return score1}, set value(v){score1=v}}, 400);
  updateBall(ball2, extraCircles, circle, {get value(){return score2}, set value(v){score2=v}}, 600);
  repelBalls(ball1, ball2);
  ctx.restore();

  circle.angle += circle.speed;
  for (let c of extraCircles) {
    c.angle += c.speed;
  }

  requestAnimationFrame(draw);
}

function toggleGravity(checked) {
  ball1.useGravity = checked;
  ball2.useGravity = checked;
  checkDisabled();
}

function toggleElasticity(checked) {
  ball1.useElasticity = checked;
  ball2.useElasticity = checked;
  checkDisabled();
}

function checkDisabled() {
  if (!ball1.useGravity && !ball1.useElasticity) {
    speedInput.disabled = false;
  } else {
    speedInput.disabled = true;
    speedInput.value = Math.sqrt(ball1.dx * ball1.dx + ball1.dy * ball1.dy).toFixed(1);
  }
}

function updateSpeed(value) {
  ball1.dx = parseFloat(value);
  ball1.dy = parseFloat(value);
  ball2.dx = -parseFloat(value);
  ball2.dy = -parseFloat(value);
}

function resizeCanvas() {
  const minSize = 900;
  canvas.width = Math.max(window.innerWidth * 0.9, minSize);
  canvas.height = Math.max(window.innerHeight * 0.9, minSize);
  circle.x = 0;
  circle.y = 0;
  for (let ball of [ball1, ball2]) {
    if (Math.sqrt(ball.x * ball.x + ball.y * ball.y) + ball.radius > circle.radius) {
      let angle = Math.atan2(ball.y, ball.x);
      ball.x = Math.cos(angle) * (circle.radius - ball.radius - 1);
      ball.y = Math.sin(angle) * (circle.radius - ball.radius - 1);
    }
  }
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);

updateScore();

draw();
</script>
</body>
</html>
