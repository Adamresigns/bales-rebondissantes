<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bouncing Ball in a Circle</title>
  <style>
    body {
      background: radial-gradient(circle at top, #11182A, #070a13);
      overflow: hidden;
      margin: 0;
    }
    canvas {
      background: radial-gradient(circle at center, #1c2a4f, #070a13 70%);
      display: block;
      margin: 0 auto;
      box-shadow: 0 0 60px #0ff, 0 0 120px #00f;
      border-radius: 20px;
    }
    #scoreDisplay, label, input {
      color: #fff;
      text-shadow: 0 0 8px #0ff, 0 0 4px #fff;
      font-weight: bold;
    }
    #scoreDisplay {
      font-size: 1.7em;
      margin-top: 10px;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.4);
      border-radius: 10px;
      padding: 6px 18px;
      display: inline-block;
      box-shadow: 0 0 10px #0ff;
    }
    input[type="number"] {
      background: #222;
      color: #0ff;
      border: 1px solid #0ff;
      border-radius: 5px;
      padding: 2px 6px;
      font-size: 1em;
      box-shadow: 0 0 6px #0ff inset;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div style="text-align:center;">
  <label for="speed">Speed:</label>
  <input type="number" id="speed" value="3" step="0.1" onchange="updateSpeed(this.value);" disabled>
  <br>
  <input type="checkbox" id="gravityToggle" onchange="toggleGravity(this.checked);">
  <label for="gravityToggle">Gravity</label>
  <br>
  <input type="checkbox" id="elasticityToggle" onchange="toggleElasticity(this.checked);">
  <label for="elasticityToggle">Elasticity</label>
  <br>
  <div id="scoreDisplay">
    <span style="color:#00f6ff;text-shadow:0 0 8px #00f6ff;">Blue</span>: <span id="score1">0</span>
    |
    <span style="color:#ff0066;text-shadow:0 0 8px #ff0066;">Red</span>: <span id="score2">0</span>
  </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const score1Display = document.getElementById('score1');
const score2Display = document.getElementById('score2');
const audioContext = new (window.AudioContext || window.webkitAudioContext)();

let score1, score2, circle, extraCircles, ball1, ball2;
let arcLength, isGameOver, shockwaves;

const neonColors = [ "#7ed6df", "#eccc68", "#ffb8b8", "#b8e994", "#f6e58d", "#dff9fb", "#f9ca24", "#f3a683", "#f7d794", "#f5cd79", "#c7ecee", "#f8a5c2", "#63cdda", "#ea8685", "#f3a683", "#f7d794" ];
const initialArcLength = 30, maxArcLength = 200, arcGrowSpeed = 0.03;
const SHRINK_RATE = 0.03, MIN_RADIUS = 30;

// NOUVEAU : Constantes pour l'effet d'ondulation
const RIPPLE_SPEED = 5;
const RIPPLE_LINE_WIDTH = 2.5;

function initializeGame() {
    isGameOver = false; score1 = 0; score2 = 0; updateScore();
    shockwaves = [];
    circle = { x: 0, y: 0, radius: 200, angle: 0, speed: 0.01, visible: false };
    extraCircles = []; arcLength = initialArcLength;

    const gap = 6, thickness = 10, baseRadius = circle.radius + gap;
    for (let i = 0; i < 23; i++) {
        const rad = baseRadius + i * (gap + thickness);
        extraCircles.push({ radius: rad, targetRadius: rad, color: neonColors[i % neonColors.length], glow: neonColors[i % neonColors.length], angle: 0, speed: 0.008 - i * 0.0002, visible: true });
    }
    
    const startRadius = 10;
    ball1 = { ...randomBallPosition(circle.radius, startRadius), radius: startRadius, targetRadius: startRadius, dx: 3, dy: 3, useGravity: false, useElasticity: false, gravity: 0.1, elasticity: 0.8 };
    do {
        ball2 = { ...randomBallPosition(circle.radius, startRadius), radius: startRadius, targetRadius: startRadius, dx: -3, dy: -3, useGravity: false, useElasticity: false, gravity: 0.1, elasticity: 0.8 };
    } while (Math.hypot(ball1.x - ball2.x, ball1.y - ball2.y) < startRadius * 2);
}

// (Les fonctions de son et les fonctions utilitaires sont minifiées)
function playHitSound(){const t=audioContext.currentTime,o=audioContext.createOscillator(),a=audioContext.createGain();o.connect(a),a.connect(audioContext.destination);const n=200+100*Math.random();o.type="triangle",a.gain.setValueAtTime(.3,t),o.frequency.setValueAtTime(n,t),a.gain.exponentialRampToValueAtTime(.001,t+.2),o.frequency.exponentialRampToValueAtTime(50,t+.15),o.start(t),o.stop(t+.2)}
function playShatterSound(){const t=audioContext.currentTime,o=audioContext.createOscillator(),a=audioContext.createGain();o.connect(a),a.connect(audioContext.destination),o.type="sine",a.gain.setValueAtTime(.5,t),o.frequency.setValueAtTime(120,t),a.gain.exponentialRampToValueAtTime(.001,t+.4),o.frequency.exponentialRampToValueAtTime(30,t+.4),o.start(t),o.stop(t+.4);const n=audioContext.createBuffer(1,.5*audioContext.sampleRate,audioContext.sampleRate),e=n.getChannelData(0);for(let c=0;c<e.length;c++)e[c]=2*Math.random()-1;const i=audioContext.createBufferSource();i.buffer=n;const s=audioContext.createGain();i.connect(s),s.connect(audioContext.destination),s.gain.setValueAtTime(.2,t),s.gain.exponentialRampToValueAtTime(.001,t+.3),i.start(t),i.stop(t+.5)}
function randomBallPosition(r,br){let a=Math.random()*(r-br-10),t=Math.random()*Math.PI*2;return{x:Math.cos(t)*a,y:Math.sin(t)*a}}
function updateScore(){score1Display.textContent=score1;score2Display.textContent=score2}
function isOnRedArc(bx,by,co,al){let d=Math.hypot(bx,by);if(Math.abs(d-co.radius)>22)return false;let a=Math.atan2(by,bx);if(a<0)a+=Math.PI*2;let aa=al/co.radius,sa=co.angle%(Math.PI*2),ea=(sa+aa)%(Math.PI*2);return sa<ea?a>=sa&&a<=ea:a>=sa||a<=ea}
function updateCircleAnimations(){for(const c of extraCircles){if(Math.abs(c.radius-c.targetRadius)>0.1){c.radius+=(c.targetRadius-c.radius)*0.1}else{c.radius=c.targetRadius}}}
function updateBallAnimations(){if(Math.abs(ball1.radius-ball1.targetRadius)>0.05)ball1.radius+=(ball1.targetRadius-ball1.radius)*0.1;if(Math.abs(ball2.radius-ball2.targetRadius)>0.05)ball2.radius+=(ball2.targetRadius-ball2.radius)*0.1}
function shrinkCirclesOverTime(){for(const c of extraCircles){if(c.visible){c.targetRadius=Math.max(c.targetRadius-SHRINK_RATE,MIN_RADIUS)}}}

// NOUVEAU : Fonction redéfinie pour l'effet d'ondulation
function updateAndDrawRipples() {
    for (let i = shockwaves.length - 1; i >= 0; i--) {
        const ripple = shockwaves[i];
        
        // Mettre à jour le rayon
        ripple.radius += RIPPLE_SPEED;

        // La supprimer si elle est sortie de l'écran
        if (ripple.radius > ripple.maxRadius) {
            shockwaves.splice(i, 1);
            continue;
        }

        // Calculer la progression de 0 (centre) à 1 (bord)
        const progress = ripple.radius / ripple.maxRadius;
        
        // L'opacité diminue à mesure que la vague s'étend
        const alpha = 1 - progress;

        // Dessiner l'ondulation
        ctx.save();
        ctx.strokeStyle = ripple.color;
        ctx.lineWidth = RIPPLE_LINE_WIDTH;
        ctx.globalAlpha = alpha;
        ctx.shadowColor = ripple.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(0, 0, ripple.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
}

function drawGameElements(){
    arcLength=Math.min(maxArcLength,arcLength+arcGrowSpeed);
    for(let c of extraCircles){
        if(!c.visible)continue;
        let a=arcLength/c.radius,sa=c.angle,ea=sa+a;
        ctx.save();ctx.lineCap='round';ctx.shadowColor=c.glow;ctx.shadowBlur=20;
        ctx.beginPath();ctx.arc(0,0,c.radius,ea,sa+2*Math.PI,false);
        ctx.strokeStyle=c.color;ctx.lineWidth=10;ctx.stroke();ctx.restore();
    }
}

function drawBall(b,c,g){ctx.save();ctx.beginPath();ctx.arc(b.x,b.y,b.radius,0,Math.PI*2);ctx.shadowColor=g;ctx.shadowBlur=40;ctx.fillStyle=c;ctx.fill();ctx.restore()}

function updateBall(b,sr,sc){
    if(b.useGravity)b.dy+=b.gravity;
    b.x+=b.dx;b.y+=b.dy;
    for(let i=extraCircles.length-1;i>=0;i--){
        let c=extraCircles[i];
        if(!c.visible)continue;
        if(isOnRedArc(b.x,b.y,c,arcLength)){
            c.visible=false;
            // NOUVEAU : Créer une ondulation lors de la destruction
            shockwaves.push({
                radius: c.radius,
                color: c.color,
                // Le rayon maximum est la distance du centre au coin du canvas
                maxRadius: Math.hypot(canvas.width / 2, canvas.height / 2)
            });
            for(const oc of extraCircles){if(oc.visible)oc.targetRadius=Math.max(oc.radius-10,30)}
            setTimeout(()=>{playShatterSound()},0);
            sr.value++;b.targetRadius=10+sr.value*0.5;updateScore();continue;
        }
        let d=Math.hypot(b.x,b.y);
        if(Math.abs(d-c.radius)<b.radius+5){
            let nx=b.x/d,ny=b.y/d,dot=b.dx*nx+b.dy*ny;
            b.dx-=2*dot*nx*(b.useElasticity?b.elasticity:1);
            b.dy-=2*dot*ny*(b.useElasticity?b.elasticity:1);
            b.x=nx*(c.radius-b.radius-5);b.y=ny*(c.radius-b.radius-5);
            playHitSound();return;
        }
    }
}

// (Le reste des fonctions est minifié)
function repelBalls(b1,b2){let dx=b2.x-b1.x,dy=b2.y-b1.y,dist=Math.sqrt(dx*dx+dy*dy),minDist=b1.radius+b2.radius;if(dist<minDist&&dist>0){let o=minDist-dist+0.1,nx=dx/dist,ny=dy/dist;b1.x-=nx*o/2;b1.y-=ny*o/2;b2.x+=nx*o/2;b2.y+=ny*o/2;let dvx=b2.dx-b1.dx,dvy=b2.dy-b1.dy,i=dvx*nx+dvy*ny;if(i<0){b1.dx+=i*nx;b1.dy+=i*ny;b2.dx-=i*nx;b2.dy-=i*ny}}}
function checkWinCondition(){if(extraCircles.every(c=>!c.visible)&&!isGameOver){isGameOver=true;setTimeout(initializeGame,5000)}}
function drawGameOverScreen(){ctx.save();ctx.fillStyle="rgba(0,0,0,0.7)";ctx.fillRect(-canvas.width/2,-canvas.height/2,canvas.width,canvas.height);ctx.fillStyle="#fff";ctx.textAlign='center';ctx.font="bold 60px sans-serif";ctx.shadowColor="#0ff";ctx.shadowBlur=20;let wt;if(score1>score2){wt="Blue Player Wins!";ctx.shadowColor="#00f6ff"}else if(score2>score1){wt="Red Player Wins!";ctx.shadowColor="#ff0066"}else{wt="It's a Tie!"}ctx.fillText("GAME OVER",0,-20);ctx.font="bold 40px sans-serif",ctx.fillText(wt,0,40),ctx.font="20px sans-serif",ctx.shadowBlur=10,ctx.fillText("Restarting...",0,100),ctx.restore()}
function toggleGravity(c){ball1.useGravity=c;ball2.useGravity=c;checkDisabled()}
function toggleElasticity(c){ball1.useElasticity=c;ball2.useElasticity=c;checkDisabled()}
function checkDisabled(){if(!ball1.useGravity&&!ball1.useElasticity){document.getElementById("speed").disabled=false}else{const e=document.getElementById("speed");e.disabled=true,e.value=Math.sqrt(ball1.dx*ball1.dx+ball1.dy*ball1.dy).toFixed(1)}}
function updateSpeed(v){const p=parseFloat(v);ball1.dx=p;ball1.dy=p;ball2.dx=-p;ball2.dy=-p}
function resizeCanvas(){const s=Math.min(window.innerWidth,window.innerHeight)*0.9;canvas.width=s;canvas.height=s}

function draw(){
    requestAnimationFrame(draw);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.translate(canvas.width/2,canvas.height/2);
    if(isGameOver){
        updateAndDrawRipples();
        drawGameElements();
        drawGameOverScreen();
    } else {
        updateCircleAnimations();
        updateBallAnimations();
        shrinkCirclesOverTime();
        updateAndDrawRipples(); // NOUVEAU : Dessiner les ondulations en arrière-plan
        drawGameElements();
        drawBall(ball1,"#00f6ff","#00f6ff");
        drawBall(ball2,"#ff0066","#ff0066");
        updateBall(ball1,{get value(){return score1},set value(v){score1=v}});
        updateBall(ball2,{get value(){return score2},set value(v){score2=v}});
        repelBalls(ball1,ball2);
        for(let c of extraCircles)c.angle+=c.speed;
        checkWinCondition();
    }
    ctx.restore();
}

document.addEventListener('DOMContentLoaded',()=>{resizeCanvas();initializeGame();draw();});
window.addEventListener('resize',resizeCanvas);
</script>
</body>
</html>
